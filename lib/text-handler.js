'use strict';
/*
 * TextHandler is a mini module explicitly created in order
 * to miniumize the exposure of the chrome authority.
 */

var debug = require('./debug').debug;

// Add-on SDK require Ci to be established with destructuring syntax.
var { Ci } = require('chrome');

// Return the nsDOMWindowUtils for the given element.
function getWindowUtils(element) {
    var win = element.ownerDocument.defaultView;
    return win.QueryInterface(Ci.nsIInterfaceRequestor)
                              .getInterface(Ci.nsIDOMWindowUtils);
}

// insertText() will insert text into
// the cursor position of the element. It sends 'input' event indirectly.
exports.insertText =
  function th_insertText(element, text) {
    debug('[th/insertText]', text);
    var isContentEditable = element.contentEditable === 'true';
    if (isContentEditable) {
      // Insert text to the content editable element
      element.ownerDocument.execCommand('inserttext', false, text);
    } else {
      // Insert text to the <input> and <textarea> elements
      element.QueryInterface(Ci.nsIDOMNSEditableElement);
      var editor = element.editor.QueryInterface(Ci.nsIPlaintextEditor);
      editor.insertText(text);
    }
  };

// sendKeyEvent will send keyboard events into the element,
// for the keypress event, it comes with a side effect of
// inserting the actual character (and the 'input' event).
exports.sendKeyEvent =
  function th_sendKeyEvent(element, type, keyCode, charCode) {
    debug('[th/sendKeyEvent]', type, keyCode, charCode);
    var utils = getWindowUtils(element);

    utils.sendKeyEvent(type, keyCode, charCode, null);
  };

// sendCompositionEvent will send composition events into the element.
// it only works on the element if the element has the focus.
// additionally, composition data will be inserted when the focus being taken
// away.
// Also, although compositionend event doesn't actually insert the string,
// the compositionend event will send 'input' event.
exports.sendCompositionEvent =
  function th_sendKeyEvent(element, type, text, locale) {
    debug('[th/sendCompositionEvent]', type, text, locale);

    // Need to block one input event generated by compositionend
    // event here.
    if (type === 'compositionend') {
      element.addEventListener('input', function blockInputEvent(evt) {
        element.removeEventListener('input', blockInputEvent, true);

        evt.stopImmediatePropagation();
        evt.preventDefault();
      }, true);
    }

    var utils = getWindowUtils(element);
    utils.sendCompositionEvent(type, text, locale);
  };
